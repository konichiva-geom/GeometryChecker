Писать цепочки следствий, типа теорема и сразу неравенство.
TriangleInequality(triiangle ABC) => AB + BC > AC
AB + BC > AC => ...
Тут сразу вторую стро ку к первой
-----

1. AB/(CD + 3) + DF

AB/(CD + 3) = (0, 1, ...)

AB/CD = CD/EF => 3 * AB * EF = CD * CD

1. Добавляем несуществующие вектора - ставим единичку в следующий простой индекс
2. Упрощение - заменяем последний простой индекс, потом все составные (из него происходящие), меняем
{
    "AB" -> [0, 1, 0...] == [{2:1}, max = 2]
    "AB * EF" -> [0, 0, 0, 1]
    "CD * CD" -> [0, 0, 0, 0, 1]
}

CD = (AB + BC + AC) / 2
P = HalfPerimeter(ABC)


AB = 3 + 2x
CD = y + x^2
EF = [0,0,0,0,0,1]

2. A > 90: A = [-90, 0, 0, 0, 0]
    A == 90: A = [-90, 0, 0, 0, 0]

Для неравенств новые обозначения. =>
Нужно как-то тспользовать равенства.

[left, right, sign >=, >]

Выражения упрощения:
TriangleInequality(triiangle ABC) => AB + BC > AC
AB + BC > AC => AB - AC + BC > 0
1. Домножить на консанту, добавить, перенести


AB + BC > AC, AB = AC =>

equal_triangles_1(XY == YZ, YM == YN, XYZ == XYZ) =>

A = [X, Y]
B = [Y, Z]

O = AB intersects CD
O in AB
O in CD

1. Много точек - разные => надо хранить много отношений разности
1. Не знаем что с этими точками - если этого нет, то точки различны
2. Точки равны

n точек. Отличающаюся от остальных, либо про нее ничо не знаем

ABC, H, D

points = {"A" -> Point()@ацк22, "B" -> Point()@ацк22}